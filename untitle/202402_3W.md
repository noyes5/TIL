## kafka

카프카를 사용하면 순서를 보장할수있다.

producer -> kafka -> consumer

1. topic이라는 주제를 통해서 원하는 값들을 저장할 수 있다.
2. 토픽 내에는 파티션0/파티션1/파티션2 과 같이 나누어져있으며 이 안에는 오프셋 형태로 값이 저장된다.(key-value에서 key 값과 유사)
3. 단 값이 저장된 이후에는 수정이나 삭제가 불가능하다. 순차적으로 기록만 가능함.
4. 기록할 파티션을 미리 결정하는건 kafka가 아니라 producer.

### producer는 키를 가지고 있을수도 있고 null 일수도 있다.

1.key가 null이라면 round-robin 형태로 데이터가 보내진다. -> 파티션0,1,2,....순 로드밸런싱을 하게 됨.
2.key가 != null 이면, 동일한 키를 공유하는 모든 메시지는 동일한 파티션에 기록된다.

카프카 메시지 구조
![Alt text](image.png)

key, value 모두 keySerializer를 통해 직렬화되어 바이너리 데이터로 바뀌어 kafka로 보내진다.

반대로 consumer에서 받을때는 KeyDeserializer를 통해 해석할 수 있게 된다.

### consumer group offset은주기적으로 값을 commit한다.

...계속 공부 중

## 비즈니스로직 처리 방법

1. 도메인모델 패턴 : 엔티티가 비즈니스 로직을 가지고 객체 지향적으로 핵심 로직 수행. 서비스 계층은 단순히 요청 위임
2. 트랜잭션 스크립트 패턴 : 엔티티에는 비즈니스로직이 거의 없고 서비스 계층에서 처리하는 것

## Jmeter 테스트

1.회원가입 할 때 동시에 가입하면 두명의 아이디가 생성됨.

-> email에 unique 키 값 넣어서 해결.

프로젝트 구조상 userService에 굉장히 자주 접근하므로 user에 캐싱도 적용해야 한다.

## 토큰 검증을 계속 넣은 이유

jwt 토큰은 인가에 대한 정보만 가지고 있다.
다른 유저의 토큰을 가지고 있는 경우, 그냥 지워버릴수가 있다.

## 결제 프로세스

레퍼런스는 큐넷과 인터파크 티켓.

1. 큐넷의 경우 결제가 완료된 시점에 갯수가 차감된다.

이로 인해서 재고가 있는 경우 결제 페이지까지는 모두 접속할 수 있지만 결제를 먼저한 사람 순으로 결제가 완료된다.

2. 인터파크 티켓의 경우 콘서트가 그 비슷한 예가 될 수 있는데, 자리를 선택하면 선택한 사람이 우선순위가 되어 10분간의 유효시간이 주어진다. 이 시간 동안 다른 사람들은 그 자리를 구입하지 못하고, 만약 원래 선택했던 사람이 10분 내 결제를 하지 못하면 원래대로 돌아간다.

-> 1,2번 모두 겪어봤으나 1번은 굉장히 유쾌하지 못했던 경험으로 남아있다. 재고가 없다면 결제 자체가 안되어야 하는데 재고를 둔 채로 결제를 먼저한 사람이 우선권을 가지는건, 마치 선착순 깃발뺏기 게임 같은 느낌이 들기 때문이다.

따라서 고민끝에 주문 버튼을 누른 순간 그 사람에게 재고를 보장해 주는 방식을 선택했다. 실제로 서비스가 진행된다면 얼마나 많은 이탈율이 있을지는 모르겠지만 이렇게 하면 유저는 구매하지도 못할 상품에 대한 주문정보나 결제정보를 입력하는 수고로움이 줄어든다.
또 이로 인하여 결제서비스까지 도달하는 트래픽도 적을 것이니 결제 서비스에 걸리는 부하도 줄일 수 있다고 생각한다.
