# 202408\_3W

## 8/12

### 해야할것

* MIRISHOP 프로젝트 리팩토링

### 한것

#### MIRISHOP 프로젝트의 분리되어있던 프로젝트를 다시 합쳐 멀티모듈 프로젝트로 변경

* 이유: 하나의 상위 프로젝트에서 여러 프로젝트를 관리하기 용이함. 실제 멀티 모듈 프로젝트처럼 서비스가 공유되는 것은 아니고, 개발 편의를 위해 이렇게 만듬. 각각 스프링 프로젝트이기 때문에 build하여 docker에 각각 배포하면 실제 서비스에서는 MSA 형태로 구조로 돌아감.
* 고민: 최상위에 굳이 쓸데없는 프로젝트가 들어갈 필요가 있을까?

### 회고

프로젝트명을 손보다보니 자연스레 패키지 구조가 보였고 애매한 것들이 많았다. 가장 눈에 띄는 것은 `redis를 email인증과 refresh token 에 각각 사용중`인것. 그리고 `token의 검증 방법이 너무 허술하다`는 느낌이었다.

redis는 굳이 두 개를 가용할 필요가 있을까라고 생각해보면 하나로도 prefix로 구분하면 충분히 가능할 것 같다는 생각이 들었다. 그리고 token에 대해서도 조금 더 detail하게 들어가보기로 했다..

기존 프로젝트 개선 계획에서 유저 서비스 인증인가 로직 강화 및 소셜 로그인 추가에 1일을 뒀는데..공부를 더 해온 시점에서 코드가 엉망인 것을 보니 그냥 못 넘어가겠다....

각각의 서비스들은 패키지명에 service라는 suffix를 붙여주었고, 이는 eureka를 통해 서비스를 등록해줄 예정이다.

***

## 8/16

### 해야할것

* MIRISHOP 프로젝트 리팩토링
  * token의 검증 방법 리팩토링
  * redis를 하나로 사용하고, email인증 개선
  * Member -> User 엔티티명 변경

### 한 것

1. token 인증을 전반적으로 수정
   * access token 및 refresh token 모두 userId 대신 userEmail만 담는 것으로 변경
   * secret key값을 인코딩하여 Key 객체로 한 번 더 감싸줌.
   * yml에서 long값을 받아오는 것이 아니라 단위를 지정하여 Duration을 받아오도록 변경.
   * 만료시간은 a.t 15분, r.t 2시간으로 축소
   * redis에 refresh token 저장시 key prefix로 'TOKEN=' 포함하여 저장
   * Claim반환 시 예외처리 로직 강화.&#x20;
2. redis 단일화, 이메일 인증 개선
   * &#x20;하나의 redis에 저장 위하여 이메일 prefix는 'EMAIL=' 포함하여 저장
3. 어노테이션 순서 수정
   *   ```java
       @Entity
       @Table(name = "users")
       @Getter
       @NoArgsConstructor
       @AllArgsConstructor
       @Builder
       ```

       순서에 상관없이 동작은 하지만 어노테이션 또한 위에서 아래로 내려가며 읽어가기 때문에 이 부분을 고려해서 메소드를 작성하기로 했다.
4. Exception 처리 단순화
   1. 각 도메인Exception 클래스를 CustomException으로 변경&#x20;

### 회고

1\. refresh token에 대해서만 고민하는데 며칠이나 걸렸다. UUID방식도 있고, 굳이 jwt를 쓰지 않고 프론트 영역에서 '브라우저 핑거프린팅', '로컬스토리지 or 쿠키를 이용한 clientId', '캔버스 핑거프린팅' 등의 다른 방식을 저장하는 것도 고려했다. 이것을 고려한 이유는 토큰 탈취 때문인데, 이전에 프로젝트를 진행할 때에 redis에 key값으로 email을 두고, value에 r.t를 두었었다. 그래서 a.t가 만료된 경우 r.t를 확인해서 유효하면 a.t, r.t를 모두 재발급하고 redis에 다시 저장했었다.\
현재 구현된 요구사항에서 중복로그인 에 대한 부분이나 새로운 기기에서의 로그인 같은 기능은 고려하지 않고 있기 때문에 기존의 방식보다 더 나은 방법이라고 생각이 들지 않았다.\
기술지원 경험을 돌아보면, 로그인을 너무 빡빡하게 구현해 놓으면 유저 경험상 좋지 못하다. 클레임과 이탈율이 높아진다. 현재 '전자기기 예약 구매' 정도로 제공하는 서비스를 정해두었고, 조금 더 디테일하게는 '특정 시기(출시이전)에 미리 구매하면 얼마의 할인'이 들어가서 구매할 수 있는 사이트를 생각하고 있다. 이런 생각에서 비롯된 것이, 중복 로그인을 제한할 필요가 있는가 이다. 물론 큐넷이나 인터파크 티켓처럼 큰 사이트라면, 다수의 매크로(?)를 이용해 되팔이를 하기 때문에 이것을 막는 것이 필수불가결이겠지만 이제 만드는 하꼬(?) 사이트에서 그것까지 고려할 필요는 없어보인다. 단, 확장에 대해서는 열려있어야 하는 것이 맞기 때문에 고려는 해두고 있어야 하는 것이 맞다.

2\. 하나의 redis에 값을 저장하고 prefix로 구분하면 나중에 여러개의 redis를 사용하더라도 db복제가 쉬울 것이다. redis를 두 개 쓰면 뭔가 고유한 값들을 저장할 수 있을 것이라 생각했는데 token이나 email이나 현재 redis를 사용하기를 session 처럼 사용하고 있을 뿐이다. 분리하기보다는 하나로 사용하는 것이 가용성 측면에서도 나을거란 판단으로 하나로 줄였다.

3\. 기존 프로젝트에서 Spring Security에서 사용하는 User와 직접 Entity로 정의한 User가 혼란을 야기할 수 있으므로 Member로 변경해서 작업하라는 조언을 듣고 그렇게 했었다. 그런데 막상 여러 프로젝트를 보니 그건 팀 내에서 정하기 나름인 것이고, 무조건적인 것은 아니었다. 또 단어에서 오는 어감이 user는 어떤 사용자를 뜻하지만, member는 어떤 team에 속한다는 느낌도 받게 된다. 따라서 user를 사용하기로 하고 모든 코드를 리팩토링 하기로 했다...

4\. 실무에서 auto increment 값을 직접 사용하면 문제가 된다 하여 찾아보았다. 분산DB에서 중복 문제가 발생할 수도 있고(이건 물론 master slave를 어떻게 설정하느냐에 따라서 해결 가능한 것같다.) `유추하기 쉬운 값을 외부에 노출하면 보안상 문제가 발생할 수 있다.`는 것이 가장 중요한 핵심이었다. 이를 해결하기 위해 UUID방식부터 다중 마스터 복제(multi-master replication)  / UUID / ULID / 티켓 서버(ticket server) / 트위터 스노플레이크 /snowflake / TSID....... 엄청난 방식들이 많이 있었다. 내가 생각한 방법은 가장 많이 사용하는 방법을 택하기로 했다. \
그것은 JPA 내부에서는 Auto increment를 사용하고, 외부에서는 uuid를 사용하는 것. uuid를 사용하면 용량이 증가하고, (16바이트) 인덱싱 때문에 성능이 안좋아지는 것을 알고 있지만, 이 부분 또한 해결해 볼 예정이다...(이 속도면 user service만 한달 하겄네....)\
\
추가로 newsfeed는 뺄까 생각 중이다. 뭔가 대기업이 인스타그램처럼 홍보하고 구독자가 팔로우하면 볼 수 있는 뉴스피드를 생각했는데 이를 위해서 사용한 mongoDB가 일단 별로고, 회사에서 잘 사용안하고, 내가 이해도가 낮기 때문이다. 공식 홈페이지에 강의가 있긴 한데, 대의를 생각했을 때 취직이 우선이기 때문에 패스하기로 한다.

## 8/17

### 해야할 것

* MIRISHOP 프로젝트 리팩토링
  * user 엔티티 및 관련 로직 리팩토링
  * user JPA 관련 설정 변경

### 한 것



### 회고

